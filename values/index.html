<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/FileTrees.jl/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/FileTrees.jl/css/franklin.css">
<link rel="stylesheet" href="/FileTrees.jl/css/poole_hyde.css">
<link rel="stylesheet" href="/FileTrees.jl/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/FileTrees.jl/assets/favicon.png">

   <title>FileTrees.jl</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 style="font-size:2em"><a href="/FileTrees.jl/">FileTrees<span style="opacity:0.4">.jl</span></a></h1>
      <p class="lead" style="font-size: 0.86em">Easy everyday parallelism with a file tree abstraction</p>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 2rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item " href="/FileTrees.jl/">Getting started</a>
      <a class="sidebar-nav-item active" href="/FileTrees.jl/values/">Values in file trees</a>
      <a class="sidebar-nav-item " href="/FileTrees.jl/tree-manipulation/">Manipulating file trees</a>
      <a class="sidebar-nav-item " href="/FileTrees.jl/lazy-parallel/">Laziness and parallelism</a>
      <a class="sidebar-nav-item " href="/FileTrees.jl/api/">API documentation</a>
      <small>EXTRAS</small>
      <a class="sidebar-nav-item " href="/FileTrees.jl/metadata/">Working with metadata</a>
      <a class="sidebar-nav-item " href="/FileTrees.jl/patterns/">Pattern matching</a>
      <a class="sidebar-nav-item " href="/FileTrees.jl/create-trees/">Creating file trees from scratch</a>
      <a class="sidebar-nav-item " href="/FileTrees.jl/split-files/">Splitting files</a>
      <a class="sidebar-nav-item " href="/FileTrees.jl/images/">Example: Images</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/shashi/FileTrees.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content"><h1 id="values_in_file_trees"><a href="#values_in_file_trees">Values in file trees</a></h1>
<p style="font-size: 1.15em; color: #333; line-height:1.5em"> And how to work with them.</p>
<p>Files and subtrees in a FileTree can have <a href="#loading-values">any value attached to them</a> &#40;not necessarily those loaded from the file itself&#41;, you can map and reduce over these values using <a href="#mapvalues"><code>mapvalues</code></a> and <a href="#reducevalues"><code>reducevalues</code></a>, or combine them by merging with other trees or <a href="#mapsubtrees_value_operations">collapsing subtrees</a>.</p>
<p>All these operations will be lazy if files are loaded lazily. Calling <a href="/FileTrees.jl/api/#exec"><code>exec</code></a>, <a href="/FileTrees.jl/api/#compute"><code>compute</code></a> or <a href="/FileTrees.jl/api/#save"><code>save</code></a> on a lazy value or tree with lazy values will cause the dependent values to be loaded and computed.</p>
<h2 id="loading_values"><a href="#loading_values">Loading values</a></h2>
<p><a href="/FileTrees.jl/api/#load"><code>FileTrees.load</code></a> can be used to load values into a tree.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> DataFrames, CSV, FileTrees

taxi_dir = FileTree(<span class="hljs-string">&quot;taxi-data&quot;</span>)

dfs = FileTrees.load(taxi_dir) <span class="hljs-keyword">do</span> file
    DataFrame(CSV.File(path(file)))
<span class="hljs-keyword">end</span></code></pre><pre><code class="plaintext hljs">taxi-data/
├─ 2019/
│  ├─ 01/
│  │  ├─ green.csv (9×20 DataFrame)
│  │  └─ yellow.csv (9×18 DataFrame)
│  └─ 02/
│     ├─ green.csv (9×20 DataFrame)
│     └─ yellow.csv (9×18 DataFrame)
└─ 2020/
   ├─ 01/
   │  ├─ green.csv (9×20 DataFrame)
   │  └─ yellow.csv (9×18 DataFrame)
   └─ 02/
      ├─ green.csv (9×20 DataFrame)
      └─ yellow.csv (9×18 DataFrame)
</code></pre>
<p>It&#39;s probably obvious, but you can load any file type and even values that have nothing to do with the file.</p>
<p>Loading can be made lazy using the <code>lazy&#61;true</code> flag. More on laziness <a href="/FileTrees.jl/lazy-parallel/">here</a>.</p>
<pre><code class="julia hljs">lazy_dfs = FileTrees.load(taxi_dir; lazy=<span class="hljs-literal">true</span>) <span class="hljs-keyword">do</span> file
    DataFrame(CSV.File(path(file)))
<span class="hljs-keyword">end</span></code></pre><pre><code class="plaintext hljs">taxi-data/
├─ 2019/
│  ├─ 01/
│  │  ├─ green.csv (Thunk(#3, (File(taxi-data/2019/01/green.csv),)))
│  │  └─ yellow.csv (Thunk(#3, (File(taxi-data/2019/01/yellow.csv),)))
│  └─ 02/
│     ├─ green.csv (Thunk(#3, (File(taxi-data/2019/02/green.csv),)))
│     └─ yellow.csv (Thunk(#3, (File(taxi-data/2019/02/yellow.csv),)))
└─ 2020/
   ├─ 01/
   │  ├─ green.csv (Thunk(#3, (File(taxi-data/2020/01/green.csv),)))
   │  └─ yellow.csv (Thunk(#3, (File(taxi-data/2020/01/yellow.csv),)))
   └─ 02/
      ├─ green.csv (Thunk(#3, (File(taxi-data/2020/02/green.csv),)))
      └─ yellow.csv (Thunk(#3, (File(taxi-data/2020/02/yellow.csv),)))
</code></pre>
<p>Below we will see the effect of each value-manipulating function when called with both lazy and non-lazy trees.</p>
<h2 id="mapvalues"><a href="#mapvalues">mapvalues</a></h2>
<p><code>mapvalues&#40;f, t::FileTree&#41;</code> applies <code>f</code> to every node in <code>t</code> which has a value loaded into it. It returns a new tree with the resultant values in place of the original ones.</p>
<p>Let&#39;s drop all but the first 5 columns of the dataframes we have loaded:</p>
<pre><code class="julia hljs">small_dfs = mapvalues(df-&gt;df[:, <span class="hljs-number">1</span>:<span class="hljs-number">5</span>], dfs)</code></pre><pre><code class="plaintext hljs">taxi-data/
├─ 2019/
│  ├─ 01/
│  │  ├─ green.csv (9×5 DataFrame)
│  │  └─ yellow.csv (9×5 DataFrame)
│  └─ 02/
│     ├─ green.csv (9×5 DataFrame)
│     └─ yellow.csv (9×5 DataFrame)
└─ 2020/
   ├─ 01/
   │  ├─ green.csv (9×5 DataFrame)
   │  └─ yellow.csv (9×5 DataFrame)
   └─ 02/
      ├─ green.csv (9×5 DataFrame)
      └─ yellow.csv (9×5 DataFrame)
</code></pre>
<p>mapvalues on a lazy tree creates a lazy tree, where the values on <code>exec</code> will be the right computed values.</p>
<pre><code class="julia hljs">small_dfs_lazy = mapvalues(df-&gt;df[:, <span class="hljs-number">1</span>:<span class="hljs-number">5</span>], lazy_dfs)</code></pre><pre><code class="plaintext hljs">taxi-data/
├─ 2019/
│  ├─ 01/
│  │  ├─ green.csv (Thunk(#71, (Thunk(#3, ...),)))
│  │  └─ yellow.csv (Thunk(#71, (Thunk(#3, ...),)))
│  └─ 02/
│     ├─ green.csv (Thunk(#71, (Thunk(#3, ...),)))
│     └─ yellow.csv (Thunk(#71, (Thunk(#3, ...),)))
└─ 2020/
   ├─ 01/
   │  ├─ green.csv (Thunk(#71, (Thunk(#3, ...),)))
   │  └─ yellow.csv (Thunk(#71, (Thunk(#3, ...),)))
   └─ 02/
      ├─ green.csv (Thunk(#71, (Thunk(#3, ...),)))
      └─ yellow.csv (Thunk(#71, (Thunk(#3, ...),)))
</code></pre>
<p>This map function should be instantaneous since it does not actually carry out the computation, instead returns a tree with lazy tasks that need to be carried out.</p>
<p><code>exec</code> will materialize these values:</p>
<pre><code class="julia hljs">exec(small_dfs_lazy)</code></pre><pre><code class="plaintext hljs">taxi-data/
├─ 2019/
│  ├─ 01/
│  │  ├─ green.csv (9×5 DataFrame)
│  │  └─ yellow.csv (9×5 DataFrame)
│  └─ 02/
│     ├─ green.csv (9×5 DataFrame)
│     └─ yellow.csv (9×5 DataFrame)
└─ 2020/
   ├─ 01/
   │  ├─ green.csv (9×5 DataFrame)
   │  └─ yellow.csv (9×5 DataFrame)
   └─ 02/
      ├─ green.csv (9×5 DataFrame)
      └─ yellow.csv (9×5 DataFrame)
</code></pre>
<h2 id="reducevalues"><a href="#reducevalues">reducevalues</a></h2>
<p><code>reducevalues&#40;f, t::FileTree&#41;</code> reduce all nodes in <code>t</code> into a single value by successively applying <code>f</code>. <code>f</code> is assumed to be <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> and an ordering that is optimal for parallelism is chosen. If <code>f</code> is not <code>associative</code>, pass <code>associative&#61;false</code> keyword argument.</p>
<pre><code class="julia hljs">first(reducevalues(vcat, small_dfs[<span class="hljs-string">r&quot;yellow.csv$&quot;</span>]), <span class="hljs-number">12</span>)</code></pre><pre><code class="plaintext hljs">12×5 DataFrame
│ Row │ VendorID │ tpep_pickup_datetime │ tpep_dropoff_datetime │ passenger_count │ trip_distance │
│     │ Int64    │ String               │ String                │ Int64           │ Float64       │
├─────┼──────────┼──────────────────────┼───────────────────────┼─────────────────┼───────────────┤
│ 1   │ 1        │ 2019-01-01 00:46:40  │ 2019-01-01 00:53:20   │ 1               │ 1.5           │
│ 2   │ 1        │ 2019-01-01 00:59:47  │ 2019-01-01 01:18:59   │ 1               │ 2.6           │
│ 3   │ 2        │ 2018-12-21 13:48:30  │ 2018-12-21 13:52:40   │ 3               │ 0.0           │
│ 4   │ 2        │ 2018-11-28 15:52:25  │ 2018-11-28 15:55:45   │ 5               │ 0.0           │
│ 5   │ 2        │ 2018-11-28 15:56:57  │ 2018-11-28 15:58:33   │ 5               │ 0.0           │
│ 6   │ 2        │ 2018-11-28 16:25:49  │ 2018-11-28 16:28:26   │ 5               │ 0.0           │
│ 7   │ 2        │ 2018-11-28 16:29:37  │ 2018-11-28 16:33:43   │ 5               │ 0.0           │
│ 8   │ 1        │ 2019-01-01 00:21:28  │ 2019-01-01 00:28:37   │ 1               │ 1.3           │
│ 9   │ 1        │ 2019-01-01 00:32:01  │ 2019-01-01 00:45:39   │ 1               │ 3.7           │
│ 10  │ 1        │ 2019-02-01 00:59:04  │ 2019-02-01 01:07:27   │ 1               │ 2.1           │
│ 11  │ 1        │ 2019-02-01 00:33:09  │ 2019-02-01 01:03:58   │ 1               │ 9.8           │
│ 12  │ 1        │ 2019-02-01 00:09:03  │ 2019-02-01 00:09:16   │ 1               │ 0.0           │</code></pre>
<pre><code class="julia hljs">reducevalues(vcat, small_dfs_lazy[<span class="hljs-string">r&quot;yellow.csv$&quot;</span>])</code></pre><pre><code class="plaintext hljs">Thunk(vcat, (Thunk(vcat, ...), Thunk(vcat, ...)))</code></pre>
<p>This returned a delayed task that to compute the result. <code>exec</code> will compute it:</p>
<pre><code class="julia hljs">first(exec(reducevalues(vcat, small_dfs_lazy[<span class="hljs-string">r&quot;yellow.csv$&quot;</span>])), <span class="hljs-number">12</span>)</code></pre><pre><code class="plaintext hljs">12×5 DataFrame
│ Row │ VendorID │ tpep_pickup_datetime │ tpep_dropoff_datetime │ passenger_count │ trip_distance │
│     │ Int64    │ String               │ String                │ Int64           │ Float64       │
├─────┼──────────┼──────────────────────┼───────────────────────┼─────────────────┼───────────────┤
│ 1   │ 1        │ 2019-01-01 00:46:40  │ 2019-01-01 00:53:20   │ 1               │ 1.5           │
│ 2   │ 1        │ 2019-01-01 00:59:47  │ 2019-01-01 01:18:59   │ 1               │ 2.6           │
│ 3   │ 2        │ 2018-12-21 13:48:30  │ 2018-12-21 13:52:40   │ 3               │ 0.0           │
│ 4   │ 2        │ 2018-11-28 15:52:25  │ 2018-11-28 15:55:45   │ 5               │ 0.0           │
│ 5   │ 2        │ 2018-11-28 15:56:57  │ 2018-11-28 15:58:33   │ 5               │ 0.0           │
│ 6   │ 2        │ 2018-11-28 16:25:49  │ 2018-11-28 16:28:26   │ 5               │ 0.0           │
│ 7   │ 2        │ 2018-11-28 16:29:37  │ 2018-11-28 16:33:43   │ 5               │ 0.0           │
│ 8   │ 1        │ 2019-01-01 00:21:28  │ 2019-01-01 00:28:37   │ 1               │ 1.3           │
│ 9   │ 1        │ 2019-01-01 00:32:01  │ 2019-01-01 00:45:39   │ 1               │ 3.7           │
│ 10  │ 1        │ 2019-02-01 00:59:04  │ 2019-02-01 01:07:27   │ 1               │ 2.1           │
│ 11  │ 1        │ 2019-02-01 00:33:09  │ 2019-02-01 01:03:58   │ 1               │ 9.8           │
│ 12  │ 1        │ 2019-02-01 00:09:03  │ 2019-02-01 00:09:16   │ 1               │ 0.0           │</code></pre>
<h2 id="mapsubtrees_value_operations"><a href="#mapsubtrees_value_operations">mapsubtrees &#43; value operations</a></h2>
<p><a href="/FileTrees.jl/api/#mapsubtrees"><code>mapsubtrees</code></a> is a powerful function since it allows you to recursively apply tree operations on subtrees of a tree.</p>
<p>See <a href="/FileTrees.jl/tree-manipulation/#mapsubtrees">more about it here</a>.</p>
<div class="page-foot">
  <div class="copyright">
    &copy; Shashi Gowda, Julian Samaroo. Last modified: September 30, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        


    
  </body>
</html>
